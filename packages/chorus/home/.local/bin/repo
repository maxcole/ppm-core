#!/usr/bin/env ruby
# frozen_string_literal: true

require 'thor'
require 'yaml'
require 'git'
require 'fileutils'
require 'pathname'
load File.expand_path('hub', __dir__)

class RepoStore
  CONFIG_FILE = Pathname.new(Dir.home).join('.config/chorus/repos.yml')
  CONFIG_DIR = Pathname.new(Dir.home).join('.config/chorus/repos.d')

  def all
    repos = {}

    if CONFIG_FILE.exist?
      content = YAML.load_file(CONFIG_FILE) || {}
      repos.merge!(content)
    end

    if CONFIG_DIR.exist?
      CONFIG_DIR.glob('*.yml').each do |file|
        content = YAML.load_file(file) || {}
        repos.merge!(content)
      end
    end

    repos
  end

  def find(name)
    all[name]
  end

  def resolve_path(path)
    hub_store.resolve(path)
  end

  def clone_repo(name, config, force: false)
    path = File.expand_path(resolve_path(config['path']))
    url = config['url']

    if Dir.exist?(path)
      puts "#{name}: Already exists at #{path}"
      return
    end

    parent_dir = File.dirname(path)

    unless Dir.exist?(parent_dir)
      missing_parents = find_missing_parent_repos(parent_dir)

      if missing_parents.any? && !force
        puts 'Warning: The following parent repositories should be cloned first:'
        missing_parents.each { |repo| puts "  - #{repo}" }
        puts 'Use --force to clone anyway, or clone parent repositories first.'
        return
      end

      if missing_parents.any? && force
        puts 'Force mode: Cloning parent repositories first...'
        missing_parents.each do |parent_name|
          clone_repo(parent_name, all[parent_name], force: force)
        end
      end

      FileUtils.mkdir_p(parent_dir)
    end

    puts "Cloning #{name} from #{url} to #{path}..."
    begin
      Git.clone(url, path)
      puts "#{name}: Cloned successfully"
    rescue Git::GitExecuteError => e
      puts "#{name}: Clone failed - #{e.message}"
    end
  end

  def status(config)
    path = File.expand_path(resolve_path(config['path']))

    unless Dir.exist?(path)
      return { state: :not_cloned }
    end

    begin
      git = Git.open(path)
      status = git.status

      uncommitted = status.changed.any? || status.added.any? || status.deleted.any?
      untracked = status.untracked.any?

      if uncommitted || untracked
        {
          state: :dirty,
          changed: status.changed.count,
          added: status.added.count,
          deleted: status.deleted.count,
          untracked: status.untracked.count
        }
      else
        { state: :clean }
      end
    rescue Git::GitExecuteError => e
      { state: :error, message: e.message }
    end
  end

  private

  def hub_store
    @hub_store ||= HubStore.new
  end

  def find_missing_parent_repos(target_dir)
    missing = []

    all.each do |repo_name, config|
      repo_path = File.expand_path(resolve_path(config['path']))

      next unless target_dir.start_with?("#{repo_path}/")

      missing << repo_name unless Dir.exist?(repo_path)
    end

    missing
  end
end

class RepoCLI < Thor
  def self.exit_on_failure? = true

  desc 'list [PATTERN]', 'List all configured repositories'
  map 'ls' => :list
  method_option :l, type: :boolean, desc: 'Long format: show path, URL, and status'
  method_option :status, type: :string, aliases: '-s', desc: 'Filter by status (CLEAN, DIRTY, NOT_CLONED, ERROR)'
  method_option :url, type: :boolean, desc: 'Return URL(s)'
  method_option :path, type: :boolean, desc: 'Return path(s)'
  def list(pattern = nil)
    repos = store.all
    if repos.empty?
      puts 'No repositories configured.'
      return
    end

    if pattern
      regex = Regexp.new(pattern)
      repos = repos.select { |name, _| name.match?(regex) }
    end

    if options[:status]
      filter_status = options[:status].upcase
      repos = repos.select { |_, config| status_label(config) == filter_status }
    end

    if options[:url]
      if repos.size == 1
        puts repos.values.first['url']
      else
        repos.each { |name, config| puts "#{name}\t#{config['url']}" }
      end
    elsif options[:path]
      if repos.size == 1
        puts store.resolve_path(repos.values.first['path'])
      else
        repos.each { |name, config| puts "#{name}\t#{store.resolve_path(config['path'])}" }
      end
    elsif options[:l]
      repos.each do |name, config|
        status = status_label(config)
        puts "#{name}\t#{store.resolve_path(config['path'])}\t#{config['url']}\t#{status}"
      end
    else
      repos.each_key { |name| puts name }
    end
  end

  desc 'clone NAME', 'Clone a repository to its configured path'
  method_option :all, type: :boolean, aliases: '-a', desc: 'Clone all repositories'
  method_option :force, type: :boolean, aliases: '-f', desc: 'Force clone even if parent repos are missing'
  def clone(name = nil)
    if options[:all]
      store.all.each { |repo_name, config| store.clone_repo(repo_name, config, force: options[:force]) }
    elsif name
      config = store.find(name)
      unless config
        puts "Repository '#{name}' not found in configuration."
        exit 1
      end
      store.clone_repo(name, config, force: options[:force])
    else
      puts 'Error: Please provide a repository name or use --all flag.'
      exit 1
    end
  end

  private

  def store = @store ||= RepoStore.new

  def status_label(config)
    status = store.status(config)

    case status[:state]
    when :not_cloned then 'NOT_CLONED'
    when :dirty then 'DIRTY'
    when :clean then 'CLEAN'
    when :error then 'ERROR'
    end
  end
end

RepoCLI.start(ARGV)

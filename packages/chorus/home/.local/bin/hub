#!/usr/bin/env ruby
# frozen_string_literal: true

require "thor"
require "yaml"
require "pathname"

class HubStore
  CONFIG_DIR = Pathname.new(Dir.home).join(".config/chorus")

  def all
    config || {}
  end

  def resolve(path)
    return path unless path.include?(':')

    label, subpath = path.split(':', 2)
    hub_path = all[label]
    return path unless hub_path

    subpath.to_s.empty? ? hub_path : File.join(hub_path, subpath)
  end

  def add(label, path)
    data = config
    data[label] = path
    save(data)
  end

  def create(name)
    hub_path = Pathname.pwd.join(name)
    hub_path.mkpath

    data = config
    data[name] = hub_path.to_s
    save(data)

    hub_path
  end

  def remove(name, force:)
    hub_path = Pathname.new(all[name])

    if hub_path.exist?
      if !force && hub_path.children.any?
        return :not_empty
      end
      hub_path.rmtree
    end

    data = config
    data.delete(name)
    save(data)

    :ok
  end

  private

  def config
    path = CONFIG_DIR.join("hubs.yml")
    return {} unless path.exist?

    YAML.load_file(path) || {}
  end

  def save(data)
    CONFIG_DIR.mkpath
    CONFIG_DIR.join("hubs.yml").write(data.to_yaml)
  end
end

class HubCLI < Thor
  def self.exit_on_failure? = true

  desc "list [LABEL] [LS_ARGS...]", "List hubs or contents of a hub directory"
  long_desc <<-LONGDESC
    Without arguments: list hub labels only

    With -l flag: list hub labels with their paths

    With LABEL: list contents of hub directory (uses system ls)

    With LABEL:SUBDIR: list contents of subdirectory within hub

    Any additional flags are passed to the system ls command when LABEL is provided.
  LONGDESC
  map ls: :list
  option :l, type: :boolean, default: false, desc: "Show paths alongside labels"
  option :path, type: :boolean, default: false, desc: "Return path(s)"
  check_unknown_options!
  stop_on_unknown_option! :list
  def list(*args)
    # Extract label from args (first non-flag argument)
    label = args.find { |arg| !arg.start_with?("-") }
    ls_args = args.reject { |arg| arg == label }

    if options[:path]
      if label
        # Return path for specific label
        hub_label, subdir = label.split(":", 2)
        hub_path = store.all[hub_label]
        if hub_path.nil?
          warn "Unknown hub: #{hub_label}"
          exit 1
        end
        target_path = subdir ? File.join(hub_path, subdir) : hub_path
        puts target_path
      else
        # Return all paths
        hubs = store.all
        if hubs.size == 1
          puts hubs.values.first
        else
          hubs.each { |name, path| puts "#{name}\t#{path}" }
        end
      end
    elsif label.nil?
      if options[:l]
        store.all.each { |name, path| puts "#{name}\t#{path}" }
      else
        store.all.each_key { |name| puts name }
      end
    else
      # Parse label:subdir format
      hub_label, subdir = label.split(":", 2)

      hub_path = store.all[hub_label]
      if hub_path.nil?
        warn "Unknown hub: #{hub_label}"
        exit 1
      end

      target_path = Pathname.new(hub_path)
      target_path = target_path.join(subdir) if subdir

      unless target_path.exist?
        warn "Path does not exist: #{target_path}"
        exit 1
      end

      exec("ls", *ls_args, target_path.to_s)
    end
  end

  desc "pwd LABEL", "Print the full path for a hub label"
  def pwd(label)
    hub_label, subdir = label.split(":", 2)

    hub_path = store.all[hub_label]
    if hub_path.nil?
      warn "Unknown hub: #{hub_label}"
      exit 1
    end

    target_path = Pathname.new(hub_path)
    target_path = target_path.join(subdir) if subdir

    puts target_path.to_s
  end

  desc "add", "Add current directory as a hub using directory name as label"
  def add
    current_path = Pathname.pwd.to_s
    label = File.basename(current_path)

    # Check if label already exists
    existing_path = store.all[label]
    if existing_path
      warn "Label '#{label}' already exists for path: #{existing_path}"
      exit 1
    end

    # Check if path already exists under another label
    existing_label = store.all.key(current_path)
    if existing_label
      warn "Warning: Path already registered as '#{existing_label}'"
    end

    store.add(label, current_path)
    puts "Added hub '#{label}' â†’ #{current_path}"
  end

  desc "new NAME", "Create a new hub in the current directory"
  def new(name)
    path = store.create(name)
    puts "Created hub '#{name}' at #{path}"
  end

  desc "rm NAME", "Remove a hub and its configuration"
  option :force, type: :boolean, default: false, aliases: "-f"
  def rm(name)
    result = store.remove(name, force: options[:force])
    if result == :not_empty
      puts "Hub '#{name}' is not empty. Use --force to delete."
    else
      puts "Removed hub '#{name}'"
    end
  end

  private

  def store = @store ||= HubStore.new
end

HubCLI.start(ARGV) if __FILE__ == $PROGRAM_NAME
